namespace Tutorial.LambdaCalculus
{
    using System;
    using System.Linq;
    using System.Linq.Expressions;

    public class CombinatorExpression : Expression
    {
        private CombinatorExpression(string name) => this.Name = name;

        public static CombinatorExpression S { get; } = new CombinatorExpression(nameof(S));

        public static CombinatorExpression K { get; } = new CombinatorExpression(nameof(K));

        public static CombinatorExpression I { get; } = new CombinatorExpression(nameof(I));

        public string Name { get; }

        public override ExpressionType NodeType { get; } = ExpressionType.Constant;

        public override Type Type { get; } = typeof(object);
    }

    public class ApplicationExpression : Expression
    {
        internal ApplicationExpression(Expression function, Expression variable)
        {
            this.Function = function;
            this.Variable = variable;
        }

        public Expression Function { get; }

        public Expression Variable { get; }

        public override ExpressionType NodeType { get; } = ExpressionType.Invoke;

        public override Type Type { get; } = typeof(object);
    }

    public static partial class SkiCompiler
    {
        public static Expression ToSki(this Expression lambdaCalculus)
        {
            // Ignore type convertion specified in code or generated by C# compiler.
            lambdaCalculus = lambdaCalculus.IgnoreTypeConvertion();

            switch (lambdaCalculus.NodeType)
            {
                case ExpressionType.Constant:
                    // 0. ToSki(S) = S, ToSki(K) = K, ToSki(I) = I.
                    if (lambdaCalculus is CombinatorExpression)
                    {
                        return lambdaCalculus;
                    }
                    break;

                case ExpressionType.Parameter:
                    // 1. ToSki(v) = v.
                    return lambdaCalculus;

                case ExpressionType.Invoke:
                    // 2. ToSki(E1(E2)) = ToSki(E1)(ToSKi(E2)).
                    ApplicationExpression application = lambdaCalculus.ToApplication();
                    return new ApplicationExpression(ToSki(application.Function), ToSki(application.Variable));

                case ExpressionType.Lambda:
                    LambdaExpression function = (LambdaExpression)lambdaCalculus;
                    ParameterExpression variable = function.Parameters.Single();
                    Expression body = function.Body.IgnoreTypeConvertion();

                    // 3. ToSki(v => E) = K(ToSki(E)), if v does not occur free in E.
                    if (!variable.IsFreeIn(body))
                    {
                        return new ApplicationExpression(CombinatorExpression.K, ToSki(body));
                    }

                    switch (body.NodeType)
                    {
                        case ExpressionType.Parameter:
                            // 4. ToSki(v => v) = I
                            if (variable == (ParameterExpression)body)
                            {
                                return CombinatorExpression.I;
                            }
                            break;

                        case ExpressionType.Lambda:
                            // 5. ToSki(v1 => v2 => E) = ToSki(v1 => ToSki(v2 => E)), if v1 occurs free in E.
                            LambdaExpression bodyFunction = (LambdaExpression)body;
                            if (variable.IsFreeIn(bodyFunction.Body))
                            {
                                return ToSki(Expression.Lambda(ToSki(bodyFunction), variable));
                            }
                            break;

                        case ExpressionType.Invoke:
                            // 6. ToSki(v => E1(E2)) = S(ToSki(v => E1))(ToSki(v => E2)).
                            ApplicationExpression bodyApplication = body.ToApplication();
                            return new ApplicationExpression(
                                new ApplicationExpression(
                                    CombinatorExpression.S,
                                    ToSki(Expression.Lambda(bodyApplication.Function, variable))),
                                ToSki(Expression.Lambda(bodyApplication.Variable, variable)));
                    }
                    break;
            }
            throw new ArgumentOutOfRangeException(nameof(lambdaCalculus));
        }
    }

    public static partial class SkiCompiler
    {
        private static Expression IgnoreTypeConvertion(this Expression lambdaCalculus) =>
            lambdaCalculus.NodeType == ExpressionType.Convert
                ? ((UnaryExpression)lambdaCalculus).Operand
                : lambdaCalculus;

        private static ApplicationExpression ToApplication(this Expression expression)
        {
            switch (expression)
            {
                case ApplicationExpression application:
                    return application;
                case InvocationExpression invocation:
                    return new ApplicationExpression(invocation.Expression, invocation.Arguments.Single());
            }
            throw new ArgumentOutOfRangeException(nameof(expression));
        }

        private static bool IsFreeIn(this ParameterExpression variable, Expression lambdaCalculus)
        {
            // Ignore type convertion specified in code or generated by C# compiler.
            lambdaCalculus = lambdaCalculus.IgnoreTypeConvertion();

            switch (lambdaCalculus.NodeType)
            {
                case ExpressionType.Invoke:
                    ApplicationExpression application = lambdaCalculus.ToApplication();
                    return variable.IsFreeIn(application.Function) || variable.IsFreeIn(application.Variable);
                case ExpressionType.Lambda:
                    LambdaExpression function = (LambdaExpression)lambdaCalculus;
                    return variable != function.Parameters.Single() && variable.IsFreeIn(function.Body);
                case ExpressionType.Parameter:
                    return variable == (ParameterExpression)lambdaCalculus;
                case ExpressionType.Constant:
                    return false;
            }
            throw new ArgumentOutOfRangeException(nameof(lambdaCalculus));
        }
    }

    public static partial class SkiCompiler
    {
        public static string ToSkiString(this Expression skiCalculus) => skiCalculus.ToSkiString(false);

        private static string ToSkiString(this Expression skiCalculus, bool parentheses)
        {
            switch (skiCalculus.NodeType)
            {
                case ExpressionType.Invoke:
                    ApplicationExpression application = (ApplicationExpression)skiCalculus;
                    return parentheses
                        ? $"({application.Function.ToSkiString(false)} {application.Variable.ToSkiString(true)})"
                        : $"{application.Function.ToSkiString(false)} {application.Variable.ToSkiString(true)}";
                case ExpressionType.Parameter:
                    return ((ParameterExpression)skiCalculus).Name;
                case ExpressionType.Constant:
                    return ((CombinatorExpression)skiCalculus).Name;
            }
            throw new ArgumentOutOfRangeException(nameof(skiCalculus));
        }
    }

    public static partial class SkiCalculus
    {
        internal static void Tuple<T1, T2>()
        {
            Expression<Func<T1, Func<T2, Tuple<T1, T2>>>>
                createTupleLambda = item1 => item2 => f => f(item1)(item2);
            Expression createTupleSki = createTupleLambda.ToSki();
            createTupleSki.ToSkiString().WriteLine();
            // S (S (K S) (S (K K) (S (K S) (S (K (S I)) (S (K K) I))))) (K (S (K K) I))
        }

#if DEMO
        internal static void And()
        {
            Expression<Func<Boolean, Func<Boolean, Boolean>>>
                andLambda = a => b => a(b)((Boolean)(@true => @false => @false));
            Expression andSki = andLambda.ToSki();
            andSki.ToSkiString());
        }
#endif

        internal static void And()
        {
            Expression<Func<Func<object, Func<object, object>>, Func<Func<object, Func<object, object>>, Func<object, Func<object, object>>>>>
                andLambda = a => b => (Func<object, Func<object, object>>)a(b)((Func<object, Func<object, object>>)(@true => @false => @false));
            Expression andSki = andLambda.ToSki();
            andSki.ToSkiString().WriteLine();
            // S (S (K S) (S (S (K S) (S (K K) I)) (K I))) (K (K (K I)))
        }

        internal static void Y<T, TResult>()
        {
            Expression<Func<Func<Func<T, TResult>, Func<T, TResult>>, Func<T, TResult>>>
                yLambda = f => ((SelfApplicableFunc<Func<T, TResult>>)(g => x => f(g(g))(x)))(g => x => f(g(g))(x));
            Expression ySki = yLambda.ToSki();
            ySki.ToSkiString().WriteLine();
            // ((S ((S ((S (K S)) ((S (K (S (K S)))) ((S (K (S (K K)))) ((S ((S (K S)) ((S (K K)) I))) (K ((S I) I))))))) (K (K I)))) ((S ((S (K S)) ((S (K (S (K S)))) ((S (K (S (K K)))) ((S ((S (K S)) ((S (K K)) I))) (K ((S I) I))))))) (K (K I))))
        }

        internal static void AggregateList<T>()
        {
            Expression<Func<T, Func<Func<object, Func<Func<object, Func<T, object>>, object>>, Func<object, Func<Func<object, Func<T, object>>, object>>>>>
                createNodeLambda = value => next => x => f => f(next(x)(f))(value);
            Expression createNodeSki = createNodeLambda.ToSki();
            createNodeSki.ToSkiString().WriteLine();
            // ((S (K (S ((S (K S)) ((S (K (S (K S)))) ((S (K (S (K (S I))))) ((S ((S (K S)) ((S (K (S (K S)))) ((S (K (S (K K)))) ((S ((S (K S)) ((S (K K)) I))) (K I)))))) (K (K I))))))))) ((S (K K)) ((S (K K)) ((S (K K)) I))))
        }
    }
}